<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js webgl - lights - physical lights</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="../examples/main.css">
</head>
<body>

<div id="container"></div>

<video id="video" style="display:none"></video>

<!--<div id="info">
	<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - Physically accurate incandescent bulb by
	<a href="http://clara.io" target="_blank" rel="noopener">Ben Houston</a><br/>
	Real world scale: Brick cube is 50 cm in size. Globe is 50 cm in diameter.<br/>
	Reinhard inline tonemapping with real-world light falloff (decay = 2).
</div>-->

<script type="module">

	import * as THREE from '../build/three.module.js';
	import {Sky} from '../examples/jsm/objects/Sky.js';
	import {OrbitControls} from '../examples/jsm/controls/OrbitControls.js';
	import {Water} from '../examples/jsm/objects/Water.js';
	import {EffectComposer} from '../examples/jsm/postprocessing/EffectComposer.js';
	import {RenderPass} from '../examples/jsm/postprocessing/RenderPass.js';
	import {ShaderPass} from '../examples/jsm/postprocessing/ShaderPass.js';
	import {OutlinePass} from '../examples/jsm/postprocessing/OutlinePass.js';
	import {FXAAShader} from '../examples/jsm/shaders/FXAAShader.js';

	let camera, scene, renderer, container, textureLoader, controls;
	let ballMat, cubeMat, floorMat, floorMesh, finishDisplayGroup, globeMesh, boxMesh, boxMesh2, boxMesh3;
	let sky, sunSphere, dirLight, dirLightHeper, hemiLight, hemiLightHelper, water;
	let video, videoMesh;
	let composer, effectFXAA, outlinePass;

	let outsideGrassMat, grassMesh, asphaltMat, asphaltMesh, ceilingMat, ceilingMesh;

	outlinePass = {
		edgeStrength: 3.6,
		edgeGlow: 0,
		edgeThickness: 2.2,
		pulsePeriod: 0
	};

	let updateBallMat = false;

	let orbitControlsDisabled = true;


	let clock = new THREE.Clock();

	let target = new THREE.Vector3();

	let lon = 90, lat = 0;
	let phi = 0, theta = 0;
	let touchX, touchY;

	let currentX = -2;
	let currentZ = -6;
	let currentY = 2;

	let pointerHelper;
	let raycaster = new THREE.Raycaster();
	let mouse = new THREE.Vector2();
	let intersection = null;

	let currentMousePos = [];

	let endPointX = -2;
	let endPointZ = -6;
	let endPointY = 2;
	let moveInXPercent = 0;
	let moveInZPercent = 0;
	let moveInYPercent = 0;
	let needToMove = false;


	init();
	animate();

	function initSky() {

		// Add Sky
		sky = new Sky();
		sky.scale.setScalar(450000);
		scene.add(sky);

		// Add Sun pointerHelper
		sunSphere = new THREE.Mesh(
				new THREE.SphereBufferGeometry(20000, 16, 8),
				new THREE.MeshBasicMaterial({color: 0xffffff})
		);
		sunSphere.position.y = -700000;
		sunSphere.visible = true;
		scene.add(sunSphere);


		let distance = 400000;

		function updateSun() {

			let uniforms = sky.material.uniforms;
			uniforms["turbidity"].value = 15.1;
			uniforms["rayleigh"].value = 1.1552;
			uniforms["mieCoefficient"].value = 0.008;
			uniforms["mieDirectionalG"].value = 0.681;
			uniforms["luminance"].value = 1;
			let sunInclination = 0.33338;
			let sunAzimuth = 0.2581;

			let theta = Math.PI * (sunInclination - 0.5);
			let phi = 2 * Math.PI * (sunAzimuth - 0.5);

			sunSphere.position.x = distance * Math.cos(phi);
			sunSphere.position.y = distance * Math.sin(phi) * Math.sin(theta);
			sunSphere.position.z = distance * Math.sin(phi) * Math.cos(theta);

			sunSphere.visible = true;

			uniforms["sunPosition"].value.copy(sunSphere.position);

			renderer.render(scene, camera);

			hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 1);
			hemiLight.color.setHSL(0.6, 1, 0.6);
			hemiLight.groundColor.setHSL(0.095, 1, 0.75);
			hemiLight.position.set(0, 70, 0);
			scene.add(hemiLight);
			//scene.add( hemiLightHelper );
			dirLight = new THREE.DirectionalLight(0xffffff, 8);
			dirLight.color.setHSL(0.1, 1, 0.95);
			dirLight.position.set(.5, 4.6, -10);
			dirLight.position.multiplyScalar(70);
			scene.add(dirLight);
			dirLight.castShadow = true;
			dirLight.shadow.mapSize.width = 2048;
			dirLight.shadow.mapSize.height = 2048;
			let d = 50;
			dirLight.shadow.camera.left = -d;
			dirLight.shadow.camera.right = d;
			dirLight.shadow.camera.top = d;
			dirLight.shadow.camera.bottom = -d;

			dirLight.shadow.camera.far = 3500;
			dirLight.shadow.bias = -0.0001;
			//helps adjust lightsource
			//dirLightHeper = new THREE.DirectionalLightHelper( dirLight, 10 );
			//scene.add( dirLightHeper );

		}

		updateSun();

	}

	function initOcean() {
		let waterGeometry = new THREE.PlaneBufferGeometry(10000, 10000);
		water = new Water(
				waterGeometry,
				{
					textureWidth: 512,
					textureHeight: 512,
					waterNormals: new THREE.TextureLoader().load('../examples/textures/waternormals.jpg', function (texture) {
						texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
					}),
					alpha: 1.0,
					sunDirection: dirLight.position.clone().normalize(),
					sunColor: 0xffffff,
					waterColor: "#83eadb",
					distortionScale: -50,
					fog: scene.fog !== undefined,
					clipBias: 1
				}
		);


		water.rotation.x = -Math.PI / 2;
		water.position.y = -30;

		scene.add(water);

	}

	function loadFloor() {
		floorMat = new THREE.MeshStandardMaterial({
			roughness: 0.8,
			color: 0xffffff,
			metalness: 0.2,
			bumpScale: 0.0005,
			side: THREE.DoubleSide
		});
		textureLoader.load("../examples/textures/hardwood2_diffuse.jpg", function (map) {

			map.wrapS = THREE.RepeatWrapping;
			map.wrapT = THREE.RepeatWrapping;
			map.anisotropy = 4;
			map.repeat.set(10, 24);
			floorMat.map = map;
			floorMat.needsUpdate = true;

		});
		textureLoader.load("../examples/textures/hardwood2_bump.jpg", function (map) {

			map.wrapS = THREE.RepeatWrapping;
			map.wrapT = THREE.RepeatWrapping;
			map.anisotropy = 4;
			map.repeat.set(10, 24);
			floorMat.bumpMap = map;
			floorMat.needsUpdate = true;

		});
		textureLoader.load("../examples/textures/hardwood2_roughness.jpg", function (map) {

			map.wrapS = THREE.RepeatWrapping;
			map.wrapT = THREE.RepeatWrapping;
			map.anisotropy = 4;
			map.repeat.set(10, 24);
			floorMat.roughnessMap = map;
			floorMat.needsUpdate = true;

		});

		let floorGeometry = new THREE.PlaneBufferGeometry(20, 20);
		floorMesh = new THREE.Mesh(floorGeometry, floorMat);
		floorMesh.receiveShadow = true;
		floorMesh.rotation.x = -Math.PI / 2.0;
		floorGeometry.computeFaceNormals();
		scene.add(floorMesh);

		//this is the pointer on the floor
		let floorPointer = new THREE.RingGeometry(.2, .25, 30, 1, 6, 6.3);
		floorPointer.translate(0, 0, -.01);
		floorPointer.rotateX(Math.PI / 2);
		pointerHelper = new THREE.Mesh(floorPointer, new THREE.MeshBasicMaterial({
			color: 0xfafafad4,
			side: THREE.DoubleSide
		}));
		scene.add(pointerHelper);

	}

	function loadOutsideGrass() {
		outsideGrassMat = new THREE.MeshStandardMaterial({
			roughness: 1,
			color: 0xffffff,
			metalness: 0,
			bumpScale: 0.1,
			side: THREE.DoubleSide
		});
		textureLoader.load("../examples/textures/sandbox/Grass_001_SD/Grass_001_COLOR.jpg", function (map) {

			map.wrapS = THREE.RepeatWrapping;
			map.wrapT = THREE.RepeatWrapping;
			map.anisotropy = 4;
			map.repeat.set(10, 24);
			outsideGrassMat.map = map;
			outsideGrassMat.needsUpdate = true;

		});
		textureLoader.load("../examples/textures/sandbox/Grass_001_SD/Grass_001_OCC.jpg", function (map) {

			map.wrapS = THREE.RepeatWrapping;
			map.wrapT = THREE.RepeatWrapping;
			map.anisotropy = 4;
			map.repeat.set(10, 24);
			outsideGrassMat.bumpMap = map;
			outsideGrassMat.needsUpdate = true;

		});
		textureLoader.load("../examples/textures/sandbox/Grass_001_SD/Grass_001_ROUGH.jpg", function (map) {

			map.wrapS = THREE.RepeatWrapping;
			map.wrapT = THREE.RepeatWrapping;
			map.anisotropy = 4;
			map.repeat.set(10, 24);
			outsideGrassMat.roughnessMap = map;
			outsideGrassMat.needsUpdate = true;

		});

		let grassGeometry = new THREE.PlaneBufferGeometry(60, 60);
		grassMesh = new THREE.Mesh(grassGeometry, outsideGrassMat);
		grassMesh.receiveShadow = false;
		grassMesh.rotation.x = -Math.PI / 2.0;
		grassMesh.position.set(0, -.1, 0);
		grassGeometry.computeFaceNormals();
		scene.add(grassMesh);
	}

	function loadOutsideAsphalt() {
		asphaltMat = new THREE.MeshStandardMaterial({
			roughness: 1,
			color: 0xffffff,
			metalness: 0,
			bumpScale: 0.1,
			side: THREE.DoubleSide
		});
		textureLoader.load("../examples/textures/sandbox/Asphalt_002_SD/Asphalt_002_COLOR.jpg", function (map) {

			map.wrapS = THREE.RepeatWrapping;
			map.wrapT = THREE.RepeatWrapping;
			map.anisotropy = 4;
			map.repeat.set(10, 24);
			asphaltMat.map = map;
			asphaltMat.needsUpdate = true;

		});
		textureLoader.load("../examples/textures/sandbox/Asphalt_002_SD/Asphalt_002_OCC.jpg", function (map) {

			map.wrapS = THREE.RepeatWrapping;
			map.wrapT = THREE.RepeatWrapping;
			map.anisotropy = 4;
			map.repeat.set(10, 24);
			asphaltMat.bumpMap = map;
			asphaltMat.needsUpdate = true;

		});
		textureLoader.load("../examples/textures/sandbox/Asphalt_002_SD/Asphalt_002_ROUGH.jpg", function (map) {

			map.wrapS = THREE.RepeatWrapping;
			map.wrapT = THREE.RepeatWrapping;
			map.anisotropy = 4;
			map.repeat.set(10, 24);
			asphaltMat.roughnessMap = map;
			asphaltMat.needsUpdate = true;

		});

		let asphaltGeometry = new THREE.PlaneBufferGeometry(30, 20);
		asphaltMesh = new THREE.Mesh(asphaltGeometry, asphaltMat);
		asphaltMesh.receiveShadow = false;
		asphaltMesh.rotation.x = -Math.PI / 2.0;
		asphaltMesh.position.set(20, -.05, 0);
		asphaltGeometry.computeFaceNormals();
		scene.add(asphaltMesh);
	}

	function loadCeiling() {
		ceilingMat = new THREE.MeshStandardMaterial({
			roughness: 1,
			color: 0xffffff,
			metalness: 0,
			bumpScale: 0.1,
			side: THREE.DoubleSide
		});
		textureLoader.load("../examples/textures/sandbox/Tiles_013_SD/Tiles_013_COLOR.jpg", function (map) {

			map.wrapS = THREE.RepeatWrapping;
			map.wrapT = THREE.RepeatWrapping;
			map.anisotropy = 4;
			map.repeat.set(10, 24);
			ceilingMat.map = map;
			ceilingMat.needsUpdate = true;

		});
		textureLoader.load("../examples/textures/sandbox/Tiles_013_SD/Tiles_013_OCC.jpg", function (map) {

			map.wrapS = THREE.RepeatWrapping;
			map.wrapT = THREE.RepeatWrapping;
			map.anisotropy = 4;
			map.repeat.set(10, 24);
			ceilingMat.bumpMap = map;
			ceilingMat.needsUpdate = true;

		});
		textureLoader.load("../examples/textures/sandbox/Tiles_013_SD/Tiles_013_ROUGH.jpg", function (map) {

			map.wrapS = THREE.RepeatWrapping;
			map.wrapT = THREE.RepeatWrapping;
			map.anisotropy = 4;
			map.repeat.set(10, 24);
			ceilingMat.roughnessMap = map;
			ceilingMat.needsUpdate = true;

		});

		let ceilingGeometry = new THREE.PlaneBufferGeometry(20, 20);
		ceilingMesh = new THREE.Mesh(ceilingGeometry, ceilingMat);
		ceilingMesh.receiveShadow = false;
		ceilingMesh.rotation.x = -Math.PI / 2.0;
		ceilingMesh.position.set(0, 10, 0);
		ceilingGeometry.computeFaceNormals();
		scene.add(ceilingMesh);
	}

	function loadDefaultObjects() {
		cubeMat = new THREE.MeshStandardMaterial({
			roughness: 0.7,
			color: 0xffffff,
			bumpScale: 0.002,
			metalness: 0.2
		});
		textureLoader.load("../examples/textures/brick_diffuse.jpg", function (map) {

			map.wrapS = THREE.RepeatWrapping;
			map.wrapT = THREE.RepeatWrapping;
			map.anisotropy = 4;
			map.repeat.set(1, 1);
			cubeMat.map = map;
			cubeMat.needsUpdate = true;

		});
		textureLoader.load("../examples/textures/brick_bump.jpg", function (map) {

			map.wrapS = THREE.RepeatWrapping;
			map.wrapT = THREE.RepeatWrapping;
			map.anisotropy = 4;
			map.repeat.set(1, 1);
			cubeMat.bumpMap = map;
			cubeMat.needsUpdate = true;

		});

		ballMat = new THREE.MeshStandardMaterial({
			color: 0xffffff,
			roughness: 0.5,
			metalness: 1.0
		});
		textureLoader.load("../examples/textures/planets/earth_atmos_2048.jpg", function (map) {

			map.anisotropy = 4;
			ballMat.map = map;
			ballMat.needsUpdate = true;

		});
		textureLoader.load("../examples/textures/planets/earth_specular_2048.jpg", function (map) {

			map.anisotropy = 4;
			ballMat.metalnessMap = map;
			ballMat.needsUpdate = true;

		});

		let ballGeometry = new THREE.SphereBufferGeometry(0.25, 32, 32);
		globeMesh = new THREE.Mesh(ballGeometry, ballMat);
		globeMesh.position.set(1, 0.25, 1);
		globeMesh.rotation.y = Math.PI;
		globeMesh.castShadow = true;
		scene.add(globeMesh);

		let boxGeometry = new THREE.BoxBufferGeometry(0.5, 0.5, 0.5);
		boxMesh = new THREE.Mesh(boxGeometry, cubeMat);
		boxMesh.position.set(-0.5, 0.25, -1);
		boxMesh.castShadow = true;
		scene.add(boxMesh);

		boxMesh2 = new THREE.Mesh(boxGeometry, cubeMat);
		boxMesh2.position.set(0, 0.25, -5);
		boxMesh2.castShadow = true;
		scene.add(boxMesh2);

		boxMesh3 = new THREE.Mesh(boxGeometry, cubeMat);
		boxMesh3.position.set(7, 0.25, 0);
		boxMesh3.castShadow = true;
		scene.add(boxMesh3);


	}

	function loadFinishSpheres() {

		finishDisplayGroup = new THREE.Group();
		scene.add(finishDisplayGroup);
		let finishSphere = new THREE.SphereBufferGeometry(.2, 64, 32);

		let diffuse = textureLoader.load("../examples/textures/carbon/Carbon.png");
		diffuse.encoding = THREE.sRGBEncoding;
		diffuse.wrapS = THREE.RepeatWrapping;
		diffuse.wrapT = THREE.RepeatWrapping;
		diffuse.repeat.x = 10;
		diffuse.repeat.y = 10;

		let normalMap = textureLoader.load("../examples/textures/carbon/Carbon_Normal.png");
		normalMap.wrapS = THREE.RepeatWrapping;
		normalMap.wrapT = THREE.RepeatWrapping;

		let normalMap2 = textureLoader.load("../examples/textures/water/Water_1_M_Normal.jpg");

		let normalMap3 = textureLoader.load("../examples/textures/flakes.png");
		normalMap3.wrapS = THREE.RepeatWrapping;
		normalMap3.wrapT = THREE.RepeatWrapping;
		normalMap3.repeat.x = 10;
		normalMap3.repeat.y = 10;
		normalMap3.anisotropy = 16;

		let normalMap4 = textureLoader.load("../examples/textures/golfball.jpg");

		let clearcoatNormaMap = textureLoader.load("../examples/textures/pbr/Scratched_gold/Scratched_gold_01_1K_Normal.png");

		// car paint

		let flakesMaterial = new THREE.MeshPhysicalMaterial({
			clearcoat: 1.0,
			clearcoatRoughness: 0.1,
			metalness: 0.9,
			roughness: 0.5,
			color: 0x0000ff,
			normalMap: normalMap3,
			normalScale: new THREE.Vector2(0.1, 0.1)
		});

		let flakesMesh = new THREE.Mesh(finishSphere, flakesMaterial);
		flakesMesh.position.x = -4;
		flakesMesh.position.y = 1.5;
		flakesMesh.position.z = -3;
		flakesMesh.castShadow = true;
		finishDisplayGroup.add(flakesMesh);

		// fibers

		let fibersMaterial = new THREE.MeshPhysicalMaterial({
			clearcoat: 1.0,
			clearcoatRoughness: 0.1,
			map: diffuse,
			normalMap: normalMap
		});
		let fibersMesh = new THREE.Mesh(finishSphere, fibersMaterial);
		fibersMesh.position.x = -4;
		fibersMesh.position.y = 1.5;
		fibersMesh.position.z = 0;
		fibersMesh.castShadow = true;

		finishDisplayGroup.add(fibersMesh);

		// golf

		let golfMaterial = new THREE.MeshPhysicalMaterial({
			metalness: 0.0,
			roughness: 0.1,
			clearcoat: 1.0,
			normalMap: normalMap4,
			clearcoatNormalMap: clearcoatNormaMap,
			clearcoatNormalScale: new THREE.Vector2(2.0, 2.0)
		});
		let golfMesh = new THREE.Mesh(finishSphere, golfMaterial);
		golfMesh.position.x = -4;
		golfMesh.position.y = 1.5;
		golfMesh.position.z = 3;
		golfMesh.castShadow = true;

		finishDisplayGroup.add(golfMesh);

		// clearcoat + normalmap

		let waterMaterial = new THREE.MeshPhysicalMaterial({
			clearcoat: 1.0,
			metalness: 1.0,
			color: 0xff0000,
			normalMap: normalMap2,
			normalScale: new THREE.Vector2(0.15, 0.15),
			clearcoatNormalMap: clearcoatNormaMap,
			clearcoatNormalScale: new THREE.Vector2(2.0, 2.0)
		});
		let waterMesh = new THREE.Mesh(finishSphere, waterMaterial);
		waterMesh.position.x = -4;
		waterMesh.position.y = 1.5;
		waterMesh.position.z = 6;
		waterMesh.castShadow = true;

		finishDisplayGroup.add(waterMesh);
	}

	function loadVideoWall() {
		video = document.getElementById('video');
		let videoTexture = new THREE.VideoTexture(video);
		let videoWallGeometry = new THREE.PlaneBufferGeometry(20, 11);
		let videoMaterial = new THREE.MeshBasicMaterial({map: videoTexture, side: THREE.DoubleSide});
		videoMesh = new THREE.Mesh(videoWallGeometry, videoMaterial);
		videoMesh.position.y = 4.5;
		videoMesh.position.z = 10;
		videoMesh.receiveShadow = false;
		videoMaterial.aoMapIntensity = 0;
		scene.add(videoMesh);
		video.src = "mp4_Boat-in-Caramoan.mp4";
		video.play();
		video.loop = true;

	}

	function updateRenderForWorld() {
		renderer = new THREE.WebGLRenderer();
		renderer.physicallyCorrectLights = true;
		renderer.gammaInput = true;
		renderer.gammaOutput = true;
		renderer.shadowMap.enabled = true;
		renderer.toneMapping = THREE.ReinhardToneMapping;
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.setSize(window.innerWidth, window.innerHeight);
		container.appendChild(renderer.domElement);

	}

	function setEventListeners() {
		window.addEventListener('resize', onWindowResize, false);
		document.addEventListener('mousedown', onDocumentMouseDown, false);
		document.addEventListener('touchstart', onDocumentTouchStart, false);
		document.addEventListener('touchmove', onDocumentTouchMove, false);
		window.addEventListener('resize', onWindowResize, false);
		container.addEventListener('mousemove', onMouseMove, false);
	}

	function initPostProcessing() {

		composer = new EffectComposer(renderer);
		let renderPass = new RenderPass(scene, camera);
		composer.addPass(renderPass);

		outlinePass = new OutlinePass(new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera);
		composer.addPass(outlinePass);
		effectFXAA = new ShaderPass(FXAAShader);
		effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
		composer.addPass(effectFXAA);


	}

	function initOrbitControls() {
		controls = new OrbitControls(camera, renderer.domElement);
		controls.screenSpacePanning = false;
		controls.minDistance = 1;
		controls.maxDistance = 3;
		controls.maxPolarAngle = Math.PI / 2;
		controls.enabled = false;
		controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
		controls.dampingFactor = 0.05;
		controls.autoRotate = true;
		controls.autoRotateSpeed = .5;
	}

	function init() {

		container = document.getElementById('container');

		camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, .1, 1000);
		camera.position.x = currentX;
		camera.position.z = currentZ;
		camera.position.y = currentY;

		scene = new THREE.Scene();

		textureLoader = new THREE.TextureLoader();

		loadFloor();

		loadOutsideGrass();

		loadOutsideAsphalt();

		loadCeiling();

		loadDefaultObjects();

		loadFinishSpheres();

		loadVideoWall();

		updateRenderForWorld();

		setEventListeners();

		initSky();

		initOcean();

		initPostProcessing();

		initOrbitControls();

	}

	function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize(window.innerWidth, window.innerHeight);
		composer.setSize(window.innerWidth, window.innerHeight);

	}

	function onDocumentMouseDown(event) {
		currentMousePos = [event.pageX, event.pageY];
		document.addEventListener('mousemove', onDocumentMouseMove, false);
		document.addEventListener('mouseup', onDocumentMouseUp, false);

	}

	function onDocumentMouseMove(event) {
		let movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
		let movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
		lon -= movementX * 0.1;
		lat += movementY * 0.1;
	}

	function onDocumentMouseUp(event) {

		document.removeEventListener('mousemove', onDocumentMouseMove);
		document.removeEventListener('mouseup', onDocumentMouseUp);
		let compareMousePosition = [event.pageX, event.pageY];
		if (JSON.stringify(compareMousePosition) === JSON.stringify(currentMousePos)) {
			clickEvent(event);
		}
	}

	function onDocumentTouchStart(event) {
		let touch = event.touches[0];
		touchX = touch.screenX;
		touchY = touch.screenY;

	}

	function onDocumentTouchMove(event) {
		let touch = event.touches[0];
		lon -= (touch.screenX - touchX) * 0.1;
		lat += (touch.screenY - touchY) * 0.1;
		touchX = touch.screenX;
		touchY = touch.screenY;

	}

	function animateCameraMovement() {


		if (needToMove && controls.enabled === false) {
			if (endPointX > currentX && ((endPointX - currentX) > 0.1)) {
				currentX += moveInXPercent;
			} else if (endPointX < currentX && ((currentX - endPointX > 0.1))) {
				currentX -= moveInXPercent;
			}
			if (endPointZ > currentZ && ((endPointZ - currentZ) > 0.1)) {
				currentZ += moveInZPercent;
			} else if (endPointZ < currentZ && ((currentZ - endPointZ > 0.1))) {
				currentZ -= moveInZPercent;
			}
			if (endPointY > currentY && ((endPointY - currentY) > 0.1)) {
				currentY += moveInYPercent;
			} else if (endPointZ < currentZ && ((currentY - endPointY > 0.1))) {
				currentY -= moveInYPercent;
			}
			if (endPointX < currentX && endPointZ < currentZ && (currentZ - endPointZ < 0.1) && (currentX - endPointX < 0.1)) {
				needToMove = false;

				if (!orbitControlsDisabled) {
					controls.enabled = true;
					controls.update();
				}

			} else if (endPointX > currentX && endPointZ > currentZ && (endPointZ - currentZ < 0.1) && (endPointX - currentX < 0.1)) {
				needToMove = false;

				if (!orbitControlsDisabled) {
					controls.enabled = true;
					controls.update();

				}

			}

			if(controls.enabled === false) {
				camera.position.x = currentX;
				camera.position.z = currentZ;
				camera.position.y = currentY;
			}
		}

		lat = Math.max(-85, Math.min(85, lat));
		phi = THREE.Math.degToRad(90 - lat);
		theta = THREE.Math.degToRad(lon);

		target.x = Math.sin(phi) * Math.cos(theta) + currentX;
		target.y = Math.cos(phi) + currentY;
		target.z = Math.sin(phi) * Math.sin(theta) + currentZ;

		if(controls.enabled === false) {
			camera.lookAt(target);
		}
		if (!orbitControlsDisabled) {
			controls.update();

			let wpVector = new THREE.Vector3();
			let cameraCoord = camera.getWorldPosition(wpVector);
			currentX = cameraCoord.x;
			currentY = cameraCoord.y;
			currentZ = cameraCoord.z;
		}

	}

	function animate() {
		requestAnimationFrame(animate);
		render();
		composer.render();

	}

	function render() {
		let timer = 0.0001 * Date.now();

		animateCameraMovement();
		renderer.render(scene, camera);

		if (updateBallMat) {
			ballMat.emissive.setHSL(0.54, 1, 0.35 * (0.5 + 0.5 * Math.sin(35 * timer)));
		}
		water.material.uniforms['time'].value += 1.0 / 60.0;

	}

	function onMouseMove(event) {

		mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
		mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
		raycaster.setFromCamera(mouse, camera);
		moveFloorPointer();
		checkForHoverOnItems();

	}

	//Add all things to test clicks against here
	function clickEvent(event) {
		mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
		mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
		raycaster.setFromCamera(mouse, camera);
		floorClick();
		videoClick();
		globeClick();

	}

	function doesIntersect(meshToTest) {
		let intersects = raycaster.intersectObject(meshToTest);
		if (intersects.length > 0) {
			return meshToTest.uuid === intersects[0].object.uuid;
		} else {
			return false;
		}
	}

	function setMovingCoordinates(x, y, z, distance) {
		endPointX = x;
		endPointZ = z;
		needToMove = true;
		let framesToMove = distance * 10; // keeps constant rate of movement, raise to slow or lower to increase speed
		if (currentX > endPointX) {
			moveInXPercent = (currentX - endPointX) / framesToMove;
		} else {
			moveInXPercent = (endPointX - currentX) / framesToMove;
		}
		if (currentZ > endPointZ) {
			moveInZPercent = (currentZ - endPointZ) / framesToMove;
		} else {
			moveInZPercent = (endPointZ - currentZ) / framesToMove;
		}
		if (currentY > endPointY) {
			moveInYPercent = (currentY - endPointY) / framesToMove;
		} else {
			moveInYPercent = (endPointY - currentY) / framesToMove;
		}
	}

	function checkForHoverOnItems() {
		let objsToCheck = [videoMesh, globeMesh, boxMesh, boxMesh2, boxMesh3];
		let noIntersection = true;
		for (let i = 0; i < objsToCheck.length; i++) {
			if (doesIntersect(objsToCheck[i])) {
				outlinePass.selectedObjects = [objsToCheck[i]];
				noIntersection = false;
			}
		}
		if (noIntersection) {
			outlinePass.selectedObjects = [];
		}
	}

	function moveFloorPointer() {
		let intersects = raycaster.intersectObject(floorMesh);
		if (intersects.length > 0) {
			pointerHelper.position.set(0, 0, 0);
			pointerHelper.lookAt(intersects[0].face.normal);
			pointerHelper.position.copy(intersects[0].point);
		}
	}

	function videoClick() {
		if (doesIntersect(videoMesh)) {
			if (video.paused === true) {
				video.play();
				video.controls = false;

			} else {
				video.pause();
				video.controls = true;
			}
		}
	}

	function floorClick() {

		if (!orbitControlsDisabled) {
			orbitControlsDisabled = true;
			controls.enabled = false;

		}

		let multipleIntersects = raycaster.intersectObjects(scene.children);
		let intersects = raycaster.intersectObject(floorMesh);

		if (intersects.length > 0) {
			if (multipleIntersects[0].object.uuid === floorMesh.uuid) {
				setMovingCoordinates(intersects[0].point.x, 2, intersects[0].point.z, intersects[0].distance)
			}
		}
	}

	function globeClick() {

		if (doesIntersect(globeMesh)) {
			updateBallMat = !updateBallMat;

			orbitControlsDisabled = false;
			let intersects = raycaster.intersectObject(globeMesh);
			setMovingCoordinates(globeMesh.position.x, globeMesh.position.y, globeMesh.position.z, intersects[0].distance)

		}
	}

</script>
</body>
</html>
