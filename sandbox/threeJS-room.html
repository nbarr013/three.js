<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js webgl - lights - physical lights</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="../examples/main.css">
</head>
<body>

<div id="container"></div>

<video id="video" style="display:none"></video>

<div id="info">
	<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - Physically accurate incandescent bulb by
	<a href="http://clara.io" target="_blank" rel="noopener">Ben Houston</a><br/>
	Real world scale: Brick cube is 50 cm in size. Globe is 50 cm in diameter.<br/>
	Reinhard inline tonemapping with real-world light falloff (decay = 2).
</div>

<script type="module">

	import * as THREE from '../build/three.module.js';

	import Stats from '../examples/jsm/libs/stats.module.js';
	import { GUI } from '../examples/jsm/libs/dat.gui.module.js';
    import { Sky } from '../examples/jsm/objects/Sky.js';
    import { CSS3DRenderer, CSS3DObject } from '../examples/jsm/renderers/CSS3DRenderer.js';


	var camera, scene, renderer,
		bulbLight, bulbMat, hemiLight, stats, container;
	var ballMat, cubeMat, floorMat, floorMesh;
    var sky, sunSphere;
    let finishDisplayGroup, videoWallMesh, video;



	// ref for lumens: http://www.power-sure.com/lumens.htm
	var bulbLuminousPowers = {
		"110000 lm (1000W)": 110000,
		"3500 lm (300W)": 3500,
		"1700 lm (100W)": 1700,
		"800 lm (60W)": 800,
		"400 lm (40W)": 400,
		"180 lm (25W)": 180,
		"20 lm (4W)": 20,
		"Off": 0
	};

	// ref for solar irradiances: https://en.wikipedia.org/wiki/Lux
	var hemiLuminousIrradiances = {
		"0.0001 lx (Moonless Night)": 0.0001,
		"0.002 lx (Night Airglow)": 0.002,
		"0.5 lx (Full Moon)": 0.5,
		"3.4 lx (City Twilight)": 3.4,
        "25 lx (Test Room)": 25,
        "50 lx (Living Room)": 50,
		"100 lx (Very Overcast)": 100,
		"350 lx (Office Room)": 350,
		"400 lx (Sunrise/Sunset)": 400,
		"1000 lx (Overcast)": 1000,
		"18000 lx (Daylight)": 18000,
		"50000 lx (Direct Sun)": 50000
	};

	var params = {
		shadows: true,
		exposure: 1,
		bulbPower: Object.keys( bulbLuminousPowers )[2],
		hemiIrradiance: Object.keys( hemiLuminousIrradiances )[5]
	};


	var target = new THREE.Vector3();

	var lon = 90, lat = 0;
	var phi = 0, theta = 0;
	var touchX, touchY;

	let currentX = - 2;
	let currentZ = - 6;
	let currentY = 2;

	var pointerHelper;
	var raycaster = new THREE.Raycaster();
	var mouse = new THREE.Vector2();
	var intersection = null;

	let currentMousePos = [];

	let endPointX = - 2;
	let endPointZ = - 6;
	let moveInXPercent = 0;
	let moveInZPercent = 0;
	let needToMove = false;



	init();
	animate();

    function initSky() {

        // Add Sky
        sky = new Sky();
        sky.scale.setScalar( 450000 );
        scene.add( sky );

        // Add Sun pointerHelper
        sunSphere = new THREE.Mesh(
            new THREE.SphereBufferGeometry( 20000, 16, 8 ),
            new THREE.MeshBasicMaterial( { color: 0xffffff } )
        );
        sunSphere.position.y = - 700000;
        sunSphere.visible = true;
        scene.add( sunSphere );


        var distance = 400000;

        function updateSun() {

            var uniforms = sky.material.uniforms;
            uniforms[ "turbidity" ].value = 15.1;
            uniforms[ "rayleigh" ].value = 1.162;
            uniforms[ "mieCoefficient" ].value = 0.008;
            uniforms[ "mieDirectionalG" ].value = 0.681;
            uniforms[ "luminance" ].value = 1;

            var theta = Math.PI * ( 0.1389 - 0.5 );
            var phi = 2 * Math.PI * ( 0.2581 - 0.5 );

            sunSphere.position.x = distance * Math.cos( phi );
            sunSphere.position.y = distance * Math.sin( phi ) * Math.sin( theta );
            sunSphere.position.z = distance * Math.sin( phi ) * Math.cos( theta );

            sunSphere.visible = true;

            uniforms[ "sunPosition" ].value.copy( sunSphere.position );

            renderer.render( scene, camera );

        }

        updateSun();

    }

    function init() {

		container = document.getElementById( 'container' );

		stats = new Stats();
		container.appendChild( stats.dom );


		camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, .1, 1000 );
		camera.position.x = currentX;
		camera.position.z = currentZ;
		camera.position.y = currentY;

		scene = new THREE.Scene();

		var bulbGeometry = new THREE.SphereBufferGeometry( 0.02, 16, 8 );
		bulbLight = new THREE.PointLight( 0xffee88, 1, 100, 2 );

		bulbMat = new THREE.MeshStandardMaterial( {
			emissive: 0xffffee,
			emissiveIntensity: 1,
			color: 0x000000
		} );
		bulbLight.add( new THREE.Mesh( bulbGeometry, bulbMat ) );
		bulbLight.position.set( 0, 2, 0 );
		bulbLight.castShadow = true;
		scene.add( bulbLight );

		hemiLight = new THREE.HemisphereLight( 0xddeeff, 0x0f0e0d, 0.02 );
		scene.add( hemiLight );

		floorMat = new THREE.MeshStandardMaterial( {
			roughness: 0.8,
			color: 0xffffff,
			metalness: 0.2,
			bumpScale: 0.0005,
			side: THREE.DoubleSide
		} );

		var textureLoader = new THREE.TextureLoader();
		textureLoader.load( "../examples/textures/hardwood2_diffuse.jpg", function ( map ) {

			map.wrapS = THREE.RepeatWrapping;
			map.wrapT = THREE.RepeatWrapping;
			map.anisotropy = 4;
			map.repeat.set( 10, 24 );
			floorMat.map = map;
			floorMat.needsUpdate = true;

		} );
		textureLoader.load( "../examples/textures/hardwood2_bump.jpg", function ( map ) {

			map.wrapS = THREE.RepeatWrapping;
			map.wrapT = THREE.RepeatWrapping;
			map.anisotropy = 4;
			map.repeat.set( 10, 24 );
			floorMat.bumpMap = map;
			floorMat.needsUpdate = true;

		} );
		textureLoader.load( "../examples/textures/hardwood2_roughness.jpg", function ( map ) {

			map.wrapS = THREE.RepeatWrapping;
			map.wrapT = THREE.RepeatWrapping;
			map.anisotropy = 4;
			map.repeat.set( 10, 24 );
			floorMat.roughnessMap = map;
			floorMat.needsUpdate = true;

		} );

		cubeMat = new THREE.MeshStandardMaterial( {
			roughness: 0.7,
			color: 0xffffff,
			bumpScale: 0.002,
			metalness: 0.2
		} );
		textureLoader.load( "../examples/textures/brick_diffuse.jpg", function ( map ) {

			map.wrapS = THREE.RepeatWrapping;
			map.wrapT = THREE.RepeatWrapping;
			map.anisotropy = 4;
			map.repeat.set( 1, 1 );
			cubeMat.map = map;
			cubeMat.needsUpdate = true;

		} );
		textureLoader.load( "../examples/textures/brick_bump.jpg", function ( map ) {

			map.wrapS = THREE.RepeatWrapping;
			map.wrapT = THREE.RepeatWrapping;
			map.anisotropy = 4;
			map.repeat.set( 1, 1 );
			cubeMat.bumpMap = map;
			cubeMat.needsUpdate = true;

		} );

		ballMat = new THREE.MeshStandardMaterial( {
			color: 0xffffff,
			roughness: 0.5,
			metalness: 1.0
		} );
		textureLoader.load( "../examples/textures/planets/earth_atmos_2048.jpg", function ( map ) {

			map.anisotropy = 4;
			ballMat.map = map;
			ballMat.needsUpdate = true;

		} );
		textureLoader.load( "../examples/textures/planets/earth_specular_2048.jpg", function ( map ) {

			map.anisotropy = 4;
			ballMat.metalnessMap = map;
			ballMat.needsUpdate = true;

		} );

		var floorGeometry = new THREE.PlaneBufferGeometry( 20, 20 );
		floorMesh = new THREE.Mesh( floorGeometry, floorMat );
		floorMesh.receiveShadow = true;
		floorMesh.rotation.x = - Math.PI / 2.0;
		floorGeometry.computeFaceNormals();
		scene.add( floorMesh );

		var ballGeometry = new THREE.SphereBufferGeometry( 0.25, 32, 32 );
		var ballMesh = new THREE.Mesh( ballGeometry, ballMat );
		ballMesh.position.set( 1, 0.25, 1 );
		ballMesh.rotation.y = Math.PI;
		ballMesh.castShadow = true;
		scene.add( ballMesh );

		var boxGeometry = new THREE.BoxBufferGeometry( 0.5, 0.5, 0.5 );
		var boxMesh = new THREE.Mesh( boxGeometry, cubeMat );
		boxMesh.position.set( - 0.5, 0.25, - 1 );
		boxMesh.castShadow = true;
		scene.add( boxMesh );

		var boxMesh2 = new THREE.Mesh( boxGeometry, cubeMat );
		boxMesh2.position.set( 0, 0.25, - 5 );
		boxMesh2.castShadow = true;
		scene.add( boxMesh2 );

		var boxMesh3 = new THREE.Mesh( boxGeometry, cubeMat );
		boxMesh3.position.set( 7, 0.25, 0 );
		boxMesh3.castShadow = true;
		scene.add( boxMesh3 );

		//this is the pointer on the floor
		let floorPointer = new THREE.RingGeometry( .2, .25, 30, 1, 6, 6.3 );
        floorPointer.translate( 0, 0, - .01 );
        floorPointer.rotateX( Math.PI / 2 );
		pointerHelper = new THREE.Mesh( floorPointer, new THREE.MeshBasicMaterial( {
			color: 0xfafafad4,
			side: THREE.DoubleSide
		} ) );
		scene.add( pointerHelper );




		//load finish spheres
        finishDisplayGroup = new THREE.Group();
        scene.add( finishDisplayGroup );
        var finishSphere = new THREE.SphereBufferGeometry( .2, 64, 32 );

        var diffuse = textureLoader.load( "../examples/textures/carbon/Carbon.png" );
        diffuse.encoding = THREE.sRGBEncoding;
        diffuse.wrapS = THREE.RepeatWrapping;
        diffuse.wrapT = THREE.RepeatWrapping;
        diffuse.repeat.x = 10;
        diffuse.repeat.y = 10;

        var normalMap = textureLoader.load( "../examples/textures/carbon/Carbon_Normal.png" );
        normalMap.wrapS = THREE.RepeatWrapping;
        normalMap.wrapT = THREE.RepeatWrapping;

        var normalMap2 = textureLoader.load( "../examples/textures/water/Water_1_M_Normal.jpg" );

        var normalMap3 = textureLoader.load( "../examples/textures/flakes.png" );
        normalMap3.wrapS = THREE.RepeatWrapping;
        normalMap3.wrapT = THREE.RepeatWrapping;
        normalMap3.repeat.x = 10;
        normalMap3.repeat.y = 10;
        normalMap3.anisotropy = 16;

        var normalMap4 = textureLoader.load( "../examples/textures/golfball.jpg" );

        var clearcoatNormaMap = textureLoader.load( "../examples/textures/pbr/Scratched_gold/Scratched_gold_01_1K_Normal.png" );

        // car paint

        var material = new THREE.MeshPhysicalMaterial( {
            clearcoat: 1.0,
            clearcoatRoughness: 0.1,
            metalness: 0.9,
            roughness: 0.5,
            color: 0x0000ff,
            normalMap: normalMap3,
            normalScale: new THREE.Vector2( 0.1, 0.1 )
        } );

        var mesh = new THREE.Mesh( finishSphere, material );
        mesh.position.x = - 4;
        mesh.position.y = 1.5;
        mesh.position.z = -3;

        finishDisplayGroup.add( mesh );

        // fibers

        var material = new THREE.MeshPhysicalMaterial( {
            clearcoat: 1.0,
            clearcoatRoughness: 0.1,
            map: diffuse,
            normalMap: normalMap
        } );
        var mesh = new THREE.Mesh( finishSphere, material );
        mesh.position.x = - 4;
        mesh.position.y = 1.5;
        mesh.position.z = 0;
        finishDisplayGroup.add( mesh );

        // golf

        var material = new THREE.MeshPhysicalMaterial( {
            metalness: 0.0,
            roughness: 0.1,
            clearcoat: 1.0,
            normalMap: normalMap4,
            clearcoatNormalMap: clearcoatNormaMap,
            clearcoatNormalScale: new THREE.Vector2( 2.0, 2.0 )
        } );
        var mesh = new THREE.Mesh( finishSphere, material );
        mesh.position.x = - 4;
        mesh.position.y = 1.5;
        mesh.position.z = 3;
        finishDisplayGroup.add( mesh );

        // clearcoat + normalmap

        var material = new THREE.MeshPhysicalMaterial( {
            clearcoat: 1.0,
            metalness: 1.0,
            color: 0xff0000,
            normalMap: normalMap2,
            normalScale: new THREE.Vector2( 0.15, 0.15 ),
            clearcoatNormalMap: clearcoatNormaMap,
            clearcoatNormalScale: new THREE.Vector2( 2.0, 2.0 )
        } );
        var mesh = new THREE.Mesh( finishSphere, material );
        mesh.position.x = - 4;
        mesh.position.y = 1.5;
        mesh.position.z = 6;

        finishDisplayGroup.add( mesh );




        // var videoWallGeometry = new THREE.PlaneBufferGeometry( 20, 10 );
        // videoWallMesh = new THREE.Mesh( videoWallGeometry, floorMat );
        // videoWallMesh.receiveShadow = false;
        // videoWallMesh.position.y = 5;
        // videoWallMesh.position.x = 10;
        // videoWallGeometry.computeFaceNormals();
        // scene.add( videoWallMesh );

        video = document.getElementById( 'video' );
        var videoTexture = new THREE.VideoTexture( video );
        var videoWallGeometry = new THREE.PlaneBufferGeometry( 16, 9 );
        var videoMaterial = new THREE.MeshBasicMaterial( { map: videoTexture, side: THREE.DoubleSide} );
		var videoMesh = new THREE.Mesh( videoWallGeometry, videoMaterial );
        videoMesh.position.y = 5;
        videoMesh.position.x = 10;
        videoMesh.receiveShadow = false;
        videoMaterial.aoMapIntensity = 0;
		scene.add( videoMesh );
        video.src = "mp4_Boat-in-Caramoan.mp4";
        video.play();


		renderer = new THREE.WebGLRenderer();
		renderer.physicallyCorrectLights = true;
		renderer.gammaInput = true;
		renderer.gammaOutput = true;
		renderer.shadowMap.enabled = true;
		renderer.toneMapping = THREE.ReinhardToneMapping;
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		container.appendChild( renderer.domElement );


		window.addEventListener( 'resize', onWindowResize, false );
		document.addEventListener( 'mousedown', onDocumentMouseDown, false );

		document.addEventListener( 'touchstart', onDocumentTouchStart, false );
		document.addEventListener( 'touchmove', onDocumentTouchMove, false );

		window.addEventListener( 'resize', onWindowResize, false );

		container.addEventListener( 'mousemove', onMouseMove, false );

		var gui = new GUI();

		gui.add( params, 'hemiIrradiance', Object.keys( hemiLuminousIrradiances ) );
		gui.add( params, 'bulbPower', Object.keys( bulbLuminousPowers ) );
		gui.add( params, 'exposure', 0, 1 );
		gui.add( params, 'shadows' );
		gui.open();

        initSky();



    }


	function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

	}

	function onDocumentMouseDown( event ) {
		currentMousePos = [ event.pageX, event.pageY ];

		event.preventDefault();

		document.addEventListener( 'mousemove', onDocumentMouseMove, false );
		document.addEventListener( 'mouseup', onDocumentMouseUp, false );

	}

	function onDocumentMouseMove( event ) {
		var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
		var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

		lon -= movementX * 0.1;
		lat += movementY * 0.1;
	}

	function onDocumentMouseUp( event ) {

		document.removeEventListener( 'mousemove', onDocumentMouseMove );
		document.removeEventListener( 'mouseup', onDocumentMouseUp );
		//Move Camera Position On Click
		let compareMousePosition = [ event.pageX, event.pageY ];
		if (JSON.stringify( compareMousePosition ) === JSON.stringify( currentMousePos )) {
			onFloorClickToMove( event );
		}
	}


	function onDocumentTouchStart( event ) {

		event.preventDefault();

		var touch = event.touches[0];

		touchX = touch.screenX;
		touchY = touch.screenY;

	}

	function onDocumentTouchMove( event ) {

		event.preventDefault();

		var touch = event.touches[0];

		lon -= ( touch.screenX - touchX ) * 0.1;
		lat += ( touch.screenY - touchY ) * 0.1;

		touchX = touch.screenX;
		touchY = touch.screenY;


	}

	function animateCameraMovement() {
		if (needToMove) {
			if (endPointX > currentX &&  ( ( endPointX - currentX ) >  0.1 )) {
				currentX += moveInXPercent;
			} else if (endPointX < currentX &&  ( (currentX - endPointX  > 0.1 ) )) {
				currentX -= moveInXPercent;
			}
			if (endPointZ > currentZ &&  ( ( endPointZ - currentZ ) > 0.1 )) {
				currentZ += moveInZPercent;
			} else if (endPointZ < currentZ &&  ( (currentZ - endPointZ  > 0.1 ) )) {
				currentZ -= moveInZPercent;
			}
			if(endPointX < currentX && endPointZ < currentZ && (currentZ - endPointZ  < 0.1 ) && (currentX - endPointX  < 0.1 )){
			    needToMove = false;
			}else if(endPointX > currentX && endPointZ > currentZ && (endPointZ - currentZ < 0.1 ) && (endPointX - currentX < 0.1 )){
                needToMove = false;
            }

			camera.position.x = currentX;
			camera.position.z = currentZ;


		}

		lat = Math.max( - 85, Math.min( 85, lat ) );
		phi = THREE.Math.degToRad( 90 - lat );
		theta = THREE.Math.degToRad( lon );

		target.x = Math.sin( phi ) * Math.cos( theta ) + currentX;
		target.y = Math.cos( phi ) + currentY;
		target.z = Math.sin( phi ) * Math.sin( theta ) + currentZ;
		camera.lookAt( target );


	}


	function animate() {

		requestAnimationFrame( animate );

		render();

	}

	var previousShadowMap = false;

	function render() {


		renderer.toneMappingExposure = Math.pow( params.exposure, 5.0 ); // to allow for very bright scenes.
		renderer.shadowMap.enabled = params.shadows;
		bulbLight.castShadow = params.shadows;
		if (params.shadows !== previousShadowMap) {

			ballMat.needsUpdate = true;
			cubeMat.needsUpdate = true;
			floorMat.needsUpdate = true;
			previousShadowMap = params.shadows;

		}
		bulbLight.power = bulbLuminousPowers[params.bulbPower];
		bulbMat.emissiveIntensity = bulbLight.intensity / Math.pow( 0.02, 2.0 ); // convert from intensity to irradiance at bulb surface

		hemiLight.intensity = hemiLuminousIrradiances[params.hemiIrradiance];
		var time = Date.now() * 0.0005;

		bulbLight.position.y = Math.cos( time ) * 10 + 1.25;


		animateCameraMovement();

		renderer.render( scene, camera );

		stats.update();

	}

	function onMouseMove( event ) {

		mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
		mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;
		raycaster.setFromCamera( mouse, camera );

		var intersects = raycaster.intersectObject( floorMesh );

		if (intersects.length > 0) {
			pointerHelper.position.set( 0, 0, 0 );
			pointerHelper.lookAt( intersects[0].face.normal );
			pointerHelper.position.copy( intersects[0].point );
		}

	}


	function onFloorClickToMove( event ) {
		mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
		mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;
		raycaster.setFromCamera( mouse, camera );
		// See if the ray from the camera into the world hits one of our meshes
		var intersects = raycaster.intersectObject( floorMesh );
		// Toggle rotation bool for meshes that we clicked
		if (intersects.length > 0) {
			endPointX = intersects[0].point.x;
			endPointZ = intersects[0].point.z;
			needToMove = true;

            let framesToMove = intersects[0].distance * 10; // keeps constant rate of movement, raise to slow or lower to increase speed

            if (currentX > endPointX) {
				moveInXPercent = ( currentX - endPointX ) / framesToMove;
			} else {
				moveInXPercent = ( endPointX - currentX ) / framesToMove;
			}
			if (currentZ > endPointZ) {
				moveInZPercent = ( currentZ - endPointZ ) / framesToMove;
			} else {
				moveInZPercent = ( endPointZ - currentZ ) / framesToMove;
			}
		}


	}


</script>
</body>
</html>
