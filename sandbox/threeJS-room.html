<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js webgl - lights - physical lights</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="../examples/main.css">
</head>
<body>

<div id="container"></div>
<div id="info">
	<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - Physically accurate incandescent bulb by
	<a href="http://clara.io" target="_blank" rel="noopener">Ben Houston</a><br/>
	Real world scale: Brick cube is 50 cm in size. Globe is 50 cm in diameter.<br/>
	Reinhard inline tonemapping with real-world light falloff (decay = 2).
</div>

<script type="module">

	import * as THREE from '../build/three.module.js';

	import Stats from '../examples/jsm/libs/stats.module.js';
	import { GUI } from '../examples/jsm/libs/dat.gui.module.js';

	import { OrbitControls } from '../examples/jsm/controls/OrbitControls.js';


	var camera, scene, renderer,
		bulbLight, bulbMat, hemiLight, stats, container;
	var ballMat, cubeMat, floorMat, floorMesh;


	// ref for lumens: http://www.power-sure.com/lumens.htm
	var bulbLuminousPowers = {
		"110000 lm (1000W)": 110000,
		"3500 lm (300W)": 3500,
		"1700 lm (100W)": 1700,
		"800 lm (60W)": 800,
		"400 lm (40W)": 400,
		"180 lm (25W)": 180,
		"20 lm (4W)": 20,
		"Off": 0
	};

	// ref for solar irradiances: https://en.wikipedia.org/wiki/Lux
	var hemiLuminousIrradiances = {
		"0.0001 lx (Moonless Night)": 0.0001,
		"0.002 lx (Night Airglow)": 0.002,
		"0.5 lx (Full Moon)": 0.5,
		"3.4 lx (City Twilight)": 3.4,
		"50 lx (Living Room)": 50,
		"100 lx (Very Overcast)": 100,
		"350 lx (Office Room)": 350,
		"400 lx (Sunrise/Sunset)": 400,
		"1000 lx (Overcast)": 1000,
		"18000 lx (Daylight)": 18000,
		"50000 lx (Direct Sun)": 50000
	};

	var params = {
		shadows: true,
		exposure: 0.68,
		bulbPower: Object.keys( bulbLuminousPowers )[2],
		hemiIrradiance: Object.keys( hemiLuminousIrradiances )[2]
	};


	var target = new THREE.Vector3();

	var lon = 90, lat = 0;
	var phi = 0, theta = 0;
	var touchX, touchY;

	let currentX = - 2;
	let currentZ = - 6;
	let currentY = 2;

	var helper;
	var raycaster = new THREE.Raycaster();
	var mouse = new THREE.Vector2();
	var intersection = null;

	let currentMousePos = [];

	let endPointX = - 2;
	let endPointZ = - 6;
	let moveInXPercent = 0;
	let moveInZPercent = 0;
	let needToMove = false;


	init();
	animate();

	function init() {

		container = document.getElementById( 'container' );

		stats = new Stats();
		container.appendChild( stats.dom );


		camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, .1, 1000 );
		camera.position.x = currentX;
		camera.position.z = currentZ;
		camera.position.y = currentY;

		scene = new THREE.Scene();

		var bulbGeometry = new THREE.SphereBufferGeometry( 0.02, 16, 8 );
		bulbLight = new THREE.PointLight( 0xffee88, 1, 100, 2 );

		bulbMat = new THREE.MeshStandardMaterial( {
			emissive: 0xffffee,
			emissiveIntensity: 1,
			color: 0x000000
		} );
		bulbLight.add( new THREE.Mesh( bulbGeometry, bulbMat ) );
		bulbLight.position.set( 0, 2, 0 );
		bulbLight.castShadow = true;
		scene.add( bulbLight );

		hemiLight = new THREE.HemisphereLight( 0xddeeff, 0x0f0e0d, 0.02 );
		scene.add( hemiLight );

		floorMat = new THREE.MeshStandardMaterial( {
			roughness: 0.8,
			color: 0xffffff,
			metalness: 0.2,
			bumpScale: 0.0005
		} );
		var textureLoader = new THREE.TextureLoader();
		textureLoader.load( "../examples/textures/hardwood2_diffuse.jpg", function ( map ) {

			map.wrapS = THREE.RepeatWrapping;
			map.wrapT = THREE.RepeatWrapping;
			map.anisotropy = 4;
			map.repeat.set( 10, 24 );
			floorMat.map = map;
			floorMat.needsUpdate = true;

		} );
		textureLoader.load( "../examples/textures/hardwood2_bump.jpg", function ( map ) {

			map.wrapS = THREE.RepeatWrapping;
			map.wrapT = THREE.RepeatWrapping;
			map.anisotropy = 4;
			map.repeat.set( 10, 24 );
			floorMat.bumpMap = map;
			floorMat.needsUpdate = true;

		} );
		textureLoader.load( "../examples/textures/hardwood2_roughness.jpg", function ( map ) {

			map.wrapS = THREE.RepeatWrapping;
			map.wrapT = THREE.RepeatWrapping;
			map.anisotropy = 4;
			map.repeat.set( 10, 24 );
			floorMat.roughnessMap = map;
			floorMat.needsUpdate = true;

		} );

		cubeMat = new THREE.MeshStandardMaterial( {
			roughness: 0.7,
			color: 0xffffff,
			bumpScale: 0.002,
			metalness: 0.2
		} );
		textureLoader.load( "../examples/textures/brick_diffuse.jpg", function ( map ) {

			map.wrapS = THREE.RepeatWrapping;
			map.wrapT = THREE.RepeatWrapping;
			map.anisotropy = 4;
			map.repeat.set( 1, 1 );
			cubeMat.map = map;
			cubeMat.needsUpdate = true;

		} );
		textureLoader.load( "../examples/textures/brick_bump.jpg", function ( map ) {

			map.wrapS = THREE.RepeatWrapping;
			map.wrapT = THREE.RepeatWrapping;
			map.anisotropy = 4;
			map.repeat.set( 1, 1 );
			cubeMat.bumpMap = map;
			cubeMat.needsUpdate = true;

		} );

		ballMat = new THREE.MeshStandardMaterial( {
			color: 0xffffff,
			roughness: 0.5,
			metalness: 1.0
		} );
		textureLoader.load( "../examples/textures/planets/earth_atmos_2048.jpg", function ( map ) {

			map.anisotropy = 4;
			ballMat.map = map;
			ballMat.needsUpdate = true;

		} );
		textureLoader.load( "../examples/textures/planets/earth_specular_2048.jpg", function ( map ) {

			map.anisotropy = 4;
			ballMat.metalnessMap = map;
			ballMat.needsUpdate = true;

		} );

		var floorGeometry = new THREE.PlaneBufferGeometry( 20, 20 );
		floorMesh = new THREE.Mesh( floorGeometry, floorMat );
		floorMesh.receiveShadow = true;
		floorMesh.rotation.x = - Math.PI / 2.0;
		floorGeometry.computeFaceNormals();
		scene.add( floorMesh );

		var ballGeometry = new THREE.SphereBufferGeometry( 0.25, 32, 32 );
		var ballMesh = new THREE.Mesh( ballGeometry, ballMat );
		ballMesh.position.set( 1, 0.25, 1 );
		ballMesh.rotation.y = Math.PI;
		ballMesh.castShadow = true;
		scene.add( ballMesh );

		var boxGeometry = new THREE.BoxBufferGeometry( 0.5, 0.5, 0.5 );
		var boxMesh = new THREE.Mesh( boxGeometry, cubeMat );
		boxMesh.position.set( - 0.5, 0.25, - 1 );
		boxMesh.castShadow = true;
		scene.add( boxMesh );

		var boxMesh2 = new THREE.Mesh( boxGeometry, cubeMat );
		boxMesh2.position.set( 0, 0.25, - 5 );
		boxMesh2.castShadow = true;
		scene.add( boxMesh2 );

		var boxMesh3 = new THREE.Mesh( boxGeometry, cubeMat );
		boxMesh3.position.set( 7, 0.25, 0 );
		boxMesh3.castShadow = true;
		scene.add( boxMesh3 );

		var geometry = new THREE.RingGeometry( .2, .25, 30, 1, 6, 6.3 );
		geometry.translate( 0, 0, - .01 );
		geometry.rotateX( Math.PI / 2 );
		helper = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( {
			color: 0xfafafad4,
			side: THREE.DoubleSide
		} ) );
		scene.add( helper );


		renderer = new THREE.WebGLRenderer();
		renderer.physicallyCorrectLights = true;
		renderer.gammaInput = true;
		renderer.gammaOutput = true;
		renderer.shadowMap.enabled = true;
		renderer.toneMapping = THREE.ReinhardToneMapping;
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		container.appendChild( renderer.domElement );


		window.addEventListener( 'resize', onWindowResize, false );
		document.addEventListener( 'mousedown', onDocumentMouseDown, false );

		document.addEventListener( 'touchstart', onDocumentTouchStart, false );
		document.addEventListener( 'touchmove', onDocumentTouchMove, false );

		window.addEventListener( 'resize', onWindowResize, false );

		container.addEventListener( 'mousemove', onMouseMove, false );

		var gui = new GUI();

		gui.add( params, 'hemiIrradiance', Object.keys( hemiLuminousIrradiances ) );
		gui.add( params, 'bulbPower', Object.keys( bulbLuminousPowers ) );
		gui.add( params, 'exposure', 0, 1 );
		gui.add( params, 'shadows' );
		gui.open();


	}


	function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

	}

	function onDocumentMouseDown( event ) {
		currentMousePos = [ event.pageX, event.pageY ];

		event.preventDefault();

		document.addEventListener( 'mousemove', onDocumentMouseMove, false );
		document.addEventListener( 'mouseup', onDocumentMouseUp, false );

	}

	function onDocumentMouseMove( event ) {
		var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
		var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

		lon -= movementX * 0.1;
		lat += movementY * 0.1;
	}

	function onDocumentMouseUp( event ) {

		document.removeEventListener( 'mousemove', onDocumentMouseMove );
		document.removeEventListener( 'mouseup', onDocumentMouseUp );
		//Move Camera Position On Click
		let compareMousePosition = [ event.pageX, event.pageY ];
		if (JSON.stringify( compareMousePosition ) === JSON.stringify( currentMousePos )) {
			onFloorClickToMove( event );
		}
	}


	function onDocumentTouchStart( event ) {

		event.preventDefault();

		var touch = event.touches[0];

		touchX = touch.screenX;
		touchY = touch.screenY;

	}

	function onDocumentTouchMove( event ) {

		event.preventDefault();

		var touch = event.touches[0];

		lon -= ( touch.screenX - touchX ) * 0.1;
		lat += ( touch.screenY - touchY ) * 0.1;

		touchX = touch.screenX;
		touchY = touch.screenY;


	}

	function animateCameraMovement() {
		if (needToMove) {
			if (endPointX > currentX &&  ( ( endPointX - currentX ) >  0.1 )) {
				currentX += moveInXPercent;
			} else if (endPointX < currentX &&  ( (currentX - endPointX  > 0.1 ) )) {
				currentX -= moveInXPercent;
			}
			if (endPointZ > currentZ &&  ( ( endPointZ - currentZ ) > 0.1 )) {
				currentZ += moveInZPercent;
			} else if (endPointZ < currentZ &&  ( (currentZ - endPointZ  > 0.1 ) )) {
				currentZ -= moveInZPercent;
			}
			if(endPointX < currentX && endPointZ < currentZ && (currentZ - endPointZ  < 0.1 ) && (currentX - endPointX  < 0.1 )){
			    needToMove = false;
			}else if(endPointX > currentX && endPointZ > currentZ && (endPointZ - currentZ < 0.1 ) && (endPointX - currentX < 0.1 )){
                needToMove = false;
            }

			camera.position.x = currentX;
			camera.position.z = currentZ;


		}

		lat = Math.max( - 85, Math.min( 85, lat ) );
		phi = THREE.Math.degToRad( 90 - lat );
		theta = THREE.Math.degToRad( lon );

		target.x = Math.sin( phi ) * Math.cos( theta ) + currentX;
		target.y = Math.cos( phi ) + currentY;
		target.z = Math.sin( phi ) * Math.sin( theta ) + currentZ;
		camera.lookAt( target );


	}


	function animate() {

		requestAnimationFrame( animate );

		render();

	}

	var previousShadowMap = false;

	function render() {


		renderer.toneMappingExposure = Math.pow( params.exposure, 5.0 ); // to allow for very bright scenes.
		renderer.shadowMap.enabled = params.shadows;
		bulbLight.castShadow = params.shadows;
		if (params.shadows !== previousShadowMap) {

			ballMat.needsUpdate = true;
			cubeMat.needsUpdate = true;
			floorMat.needsUpdate = true;
			previousShadowMap = params.shadows;

		}
		bulbLight.power = bulbLuminousPowers[params.bulbPower];
		bulbMat.emissiveIntensity = bulbLight.intensity / Math.pow( 0.02, 2.0 ); // convert from intensity to irradiance at bulb surface

		hemiLight.intensity = hemiLuminousIrradiances[params.hemiIrradiance];
		var time = Date.now() * 0.0005;

		bulbLight.position.y = Math.cos( time ) * 0.75 + 1.25;


		animateCameraMovement();

		renderer.render( scene, camera );

		stats.update();

	}

	function onMouseMove( event ) {

		mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
		mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;
		raycaster.setFromCamera( mouse, camera );

		var intersects = raycaster.intersectObject( floorMesh );

		if (intersects.length > 0) {
			helper.position.set( 0, 0, 0 );
			helper.lookAt( intersects[0].face.normal );
			helper.position.copy( intersects[0].point );
		}

	}


	function onFloorClickToMove( event ) {
		mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
		mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;
		raycaster.setFromCamera( mouse, camera );
		// See if the ray from the camera into the world hits one of our meshes
		var intersects = raycaster.intersectObject( floorMesh );
		// Toggle rotation bool for meshes that we clicked
		if (intersects.length > 0) {
			endPointX = intersects[0].point.x;
			endPointZ = intersects[0].point.z;
			needToMove = true;

            let framesToMove = intersects[0].distance * 10;

            if (currentX > endPointX) {
				moveInXPercent = ( currentX - endPointX ) / framesToMove;
			} else {
				moveInXPercent = ( endPointX - currentX ) / framesToMove;
			}
			if (currentZ > endPointZ) {
				moveInZPercent = ( currentZ - endPointZ ) / framesToMove;
			} else {
				moveInZPercent = ( endPointZ - currentZ ) / framesToMove;
			}
		}


	}


</script>
</body>
</html>
