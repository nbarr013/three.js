<!DOCTYPE html>
<html lang="en">
<head>
	<title>Picture Particles</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="../examples/main.css">
</head>
<body>
<div id="container"></div>

<script type="x-shader/x-vertex" id="vertexShader">
  // uniform float amplitude;
  // attribute float size;
  uniform float amplitude;

  attribute vec3 vertexColor;

  varying vec4 varColor;

  void main()
  {
  varColor = vec4(vertexColor, 1.0);

  vec4 pos = vec4(position, 1.0);
  pos.z *= amplitude;

  vec4 mvPosition = modelViewMatrix * pos;

  gl_PointSize = 1.0;
  gl_Position = projectionMatrix * mvPosition;
  }
</script>

<script type="x-shader/x-fragment" id="fragmentShader">
  varying vec4 varColor;

  void main()
  {
  gl_FragColor = varColor;
  }
</script>


<script type="module">

	import * as THREE from '../build/three.module.js';
	import { TrackballControls } from '../examples/jsm/controls/TrackballControls.js';

	let container;
	let camera, scene, renderer;
	let controls;

	let shaderUniforms, shaderAttributes;

	let particles = [];
	let particleSystem;

	let imageWidth = 640;
	let imageHeight = 360;
	let imageData = null;

	let animationTime = 0;
	let animationDelta = 0.03;

	init();
	animate();

	function createScene() {
		container = document.getElementById('container');

		scene = new THREE.Scene();

		camera = new THREE.PerspectiveCamera(20, window.innerWidth / window.innerHeight, 1, 10000);
		camera.position.z = 3000;
		camera.lookAt(scene.position);

		renderer = new THREE.WebGLRenderer({
			antialias: true
		});
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.setClearColor(0x000000, 1);

		container.appendChild(renderer.domElement);
	}

	function createControls() {
		controls = new TrackballControls(camera);

		controls.rotateSpeed = 1.0;
		controls.zoomSpeed = 1.2;
		controls.panSpeed = 0.8;

		controls.noZoom = false;
		controls.noPan = true;

		controls.staticMoving = true;
		controls.dynamicDampingFactor = 0.3;
	}

	function createPixelData() {
		let image = document.createElement("img");
		let canvas = document.createElement("canvas");
		let context = canvas.getContext("2d");

		image.crossOrigin = "Anonymous";
		image.onload = function() {
			image.width = canvas.width = imageWidth;
			image.height = canvas.height = imageHeight;

			context.fillStyle = context.createPattern(image, 'no-repeat');
			context.fillRect(0, 0, imageWidth, imageHeight);
			//context.drawImage(image, 0, 0, imageWidth, imageHeight);

			imageData = context.getImageData(0, 0, imageWidth, imageHeight).data;

			createPaticles();
			animate();
		};

		image.src = "https://s3-us-west-2.amazonaws.com/s.cdpn.io/175711/tree_star.jpg";
	}

	function init() {

		createScene();
		createControls();
		createPixelData();

		window.addEventListener('resize', onWindowResize, false);
	}

	function createPaticles() {
		let colors = [];
		let weights = [0.2126, 0.7152, 0.0722];
		let c = 0;

		let geometry, material;
		let x, y;
		let zRange = 400;

		geometry = new THREE.Geometry();
		geometry.dynamic = false;

		x = imageWidth * -0.5;
		y = imageHeight * 0.5;

		shaderAttributes = {
			vertexColor: {
				type: "c",
				value: []
			}
		};

		shaderUniforms = {
			amplitude: {
				type: "f",
				value: 0.5
			}
		};

		let shaderMaterial = new THREE.ShaderMaterial({
			attributes: shaderAttributes,
			uniforms: shaderUniforms,
			vertexShader: document.getElementById("vertexShader").textContent,
			fragmentShader: document.getElementById("fragmentShader").textContent
		});

		for (let i = 0; i < imageHeight; i++) {
			for (let j = 0; j < imageWidth; j++) {
				let color = new THREE.Color();

				color.setRGB(imageData[c] / 255, imageData[c + 1] / 255, imageData[c + 2] / 255);
				shaderAttributes.vertexColor.value.push(color);

				let weight = color.r * weights[0] +
						color.g * weights[1] +
						color.b * weights[2];

				let vertex = new THREE.Vector3();

				vertex.x = x;
				vertex.y = y;
				vertex.z = (zRange * -0.5) + (zRange * weight);

				geometry.vertices.push(vertex);

				c += 4;
				x++;
			}

			x = imageWidth * -0.5;
			y--;
		}
		console.log(geometry.vertices.length);
		particleSystem = new THREE.ParticleSystem(geometry, shaderMaterial);

		scene.add(particleSystem);
	}

	function tick() {
		requestAnimationFrame(tick);

		update();
		render();
	}


	function onWindowResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize(window.innerWidth, window.innerHeight);

	}

	function animate() {

		requestAnimationFrame(animate);
		render();
		update();

	}



	function render() {

		renderer.render(scene, camera);

	}

</script>
</body>
</html>
