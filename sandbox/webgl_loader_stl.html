<!DOCTYPE html>
<html lang="en">
<head>
	<title>Allegion Products</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="../examples/main.css">
</head>
<body>
<div id="info">
	<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> -
</div>

<script type="module">

	import * as THREE from '../build/three.module.js';

	import Stats from '../examples/jsm/libs/stats.module.js';
	import {OrbitControls} from '../examples/jsm/controls/OrbitControls.js';
	import {STLLoader} from '../examples/jsm/loaders/STLLoader.js';

	import {EffectComposer} from '../examples/jsm/postprocessing/EffectComposer.js';
	import {RenderPass} from '../examples/jsm/postprocessing/RenderPass.js';
	import {ShaderPass} from '../examples/jsm/postprocessing/ShaderPass.js';
	import {OutlinePass} from '../examples/jsm/postprocessing/OutlinePass.js';
	import {FXAAShader} from '../examples/jsm/shaders/FXAAShader.js';


	var container, stats;

	var camera, controls, cameraTarget, scene, renderer, loader;
	let composer, effectFXAA, outlinePass;
	let raycaster = new THREE.Raycaster();
	let mouse = new THREE.Vector2();
	let intersection = null;

	let doorHandleMaterial, doorHandleMesh;
	let camLockMaterial, camLockMesh;
	let pushBtnMaterial, pushBtnMesh;
	let krytMaterial, krytMesh;
	let pushBarMaterial, pushBarMesh;
	let allMeshsLoaded;
	let numberOfMeshsLoaded = 0;


	init();
	animate();

	function initControls() {
		controls = new OrbitControls(camera, renderer.domElement);

		controls.enableDamping = true;
		controls.dampingFactor = 0.05;

		controls.screenSpacePanning = true;

		controls.minDistance = 0;
		controls.maxDistance = 500;

	}


	function meshLoaded(id){
		let meshArr = [doorHandleMesh, camLockMesh, pushBtnMesh, krytMesh, pushBarMesh];
		for(let i = 0; i < meshArr.length; i++){
			if(id === meshArr[i].uuid){
				numberOfMeshsLoaded++;
			}
		}
		if(numberOfMeshsLoaded === meshArr.length){
			allMeshsLoaded = true;
		}
	}
	var onLoad = function ( texture ) {

		console.log(texture);
		console.log("running")
		let meshArr = [doorHandleMesh, camLockMesh, pushBtnMesh, krytMesh, pushBarMesh];
		for(let i = 0; i < meshArr.length; i++){
			if(texture.uuid === meshArr[i].uuid){
				numberOfMeshsLoaded++;
			}
		}
		if(numberOfMeshsLoaded === meshArr.length){
			allMeshsLoaded = true;
		}
	};


	function loadDoorHandle() {
		loader.load('../sandbox/models/door-handle/door-handle.stl', function (geometry) {

			doorHandleMaterial = new THREE.MeshPhongMaterial({color: "#989699", specular: 0x111111, shininess: 200});
			geometry.scale(.25, .25, .25);
			doorHandleMesh = new THREE.Mesh(geometry, doorHandleMaterial);

			doorHandleMesh.position.set(0, .01, 4);
			doorHandleMesh.rotation.set(0, -Math.PI / 2, 0);
			doorHandleMesh.scale.set(0.5, 0.5, 0.5);

			doorHandleMesh.castShadow = true;
			doorHandleMesh.receiveShadow = true;

			scene.add(doorHandleMesh);

		}/*, onLoad*/);

	}

	function loadCamLocks() {
		loader.load('../sandbox/models/sts-cam-locks/Bravica.stl', function (geometry) {

			camLockMaterial = new THREE.MeshPhongMaterial({color: '#84847a', specular: 0x111111, shininess: 200});
			if (geometry.hasColors) {
				camLockMaterial = new THREE.MeshPhongMaterial({
					opacity: geometry.alpha,
					vertexColors: THREE.VertexColors
				});
			}

			camLockMesh = new THREE.Mesh(geometry, camLockMaterial);

			camLockMesh.position.set(4, 0.2, -2);
			camLockMesh.rotation.set(-Math.PI / 2, Math.PI / 2, 0);
			camLockMesh.scale.set(0.3, 0.3, 0.3);

			camLockMesh.castShadow = true;
			camLockMesh.receiveShadow = true;

			scene.add(camLockMesh);

		}/*, onLoad*/);

	}

	function loadSchlagePushButton() {
		pushBtnMaterial = new THREE.MeshPhongMaterial({color: 0xAAAAAA, specular: 0x111111, shininess: 200});

		loader.load('../sandbox/models/SCHLAGE 625 BL-H-DP.stl', function (geometry) {
			geometry.scale(.2, .2, .2);
			pushBtnMesh = new THREE.Mesh(geometry, pushBtnMaterial);

			pushBtnMesh.position.set(0, -1, -0.6);
			pushBtnMesh.rotation.set(-Math.PI / 2, 0, 0);
			pushBtnMesh.scale.set(0.3, 0.3, 0.3);

			pushBtnMesh.castShadow = true;
			pushBtnMesh.receiveShadow = true;

			scene.add(pushBtnMesh);

		}/*, onLoad*/);

	}

	function loadKryptULock() {
		krytMaterial = new THREE.MeshPhongMaterial({color: 0xAAAAAA, specular: 0x111111, shininess: 200});

		loader.load('../sandbox/models/U-Lock-Fahgettaboudit.stl', function (geometry) {
			geometry.scale(.2, .2, .2);
			krytMesh = new THREE.Mesh(geometry, krytMaterial);

			krytMesh.position.set(0, 0, -3);
			krytMesh.rotation.set(-Math.PI / 2, 0, 0);
			krytMesh.scale.set(0.3, 0.3, 0.3);

			krytMesh.castShadow = true;
			krytMesh.receiveShadow = true;

			scene.add(krytMesh);

		}/*, onLoad*/);

	}

	function loadVonDuprinItems() {
		pushBarMaterial = new THREE.MeshPhongMaterial({color: 0xAAAAAA, specular: 0x111111, shininess: 200});

		loader.load('../sandbox/models/9957 3-Point Panic.stl', function (geometry) {
			geometry.scale(.2, .2, .2);
			pushBarMesh = new THREE.Mesh(geometry, pushBarMaterial);

			pushBarMesh.position.set(4, 0, 0);
			pushBarMesh.rotation.set(-Math.PI / 2, 0, 0);
			pushBarMesh.scale.set(0.3, 0.3, 0.3);
			pushBarMesh.rotateZ(90);

			pushBarMesh.castShadow = true;
			pushBarMesh.receiveShadow = true;

			scene.add(pushBarMesh);

		}/*, onLoad*/);
	}

	function loadItems() {
		loadDoorHandle();
		loadCamLocks();
		loadSchlagePushButton();
		loadKryptULock();
		loadVonDuprinItems();
	}

	function doesIntersect(meshToTest) {
		let intersects = raycaster.intersectObject(meshToTest);
		if (intersects.length > 0) {
			return meshToTest.uuid === intersects[0].object.uuid;
		} else {
			return false;
		}
	}

	function checkForHoverOnItems() {
		let objsToCheck =  [doorHandleMesh, camLockMesh, pushBtnMesh, krytMesh, pushBarMesh];

/* TODO add check for hover
		if (allMeshsLoaded){
			objsToCheck = [doorHandleMesh, camLockMesh, pushBtnMesh, krytMesh, pushBarMesh];
		}
*/

		let noIntersection = true;
		for (let i = 0; i < objsToCheck.length; i++) {
			if (doesIntersect(objsToCheck[i])) {
				outlinePass.selectedObjects = [objsToCheck[i]];
				noIntersection = false;
			}
		}
		if (noIntersection) {
			outlinePass.selectedObjects = [];
		}
	}

	function onMouseMove(event) {
		mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
		mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
		raycaster.setFromCamera(mouse, camera);
		checkForHoverOnItems();
	}

	function setEventListeners() {
		container.addEventListener('mousemove', onMouseMove, false);
	}

	function initPostProcessing() {

		composer = new EffectComposer(renderer);
		let renderPass = new RenderPass(scene, camera);
		composer.addPass(renderPass);

		outlinePass = new OutlinePass(new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera);
		composer.addPass(outlinePass);
		effectFXAA = new ShaderPass(FXAAShader);
		effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
		composer.addPass(effectFXAA);


	}

	function init() {

		container = document.createElement('div');
		document.body.appendChild(container);

		camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, .1, 1000);
		camera.position.set(3, 0.15, 3);

		cameraTarget = new THREE.Vector3(0, -0.25, 0);

		scene = new THREE.Scene();
		scene.background = new THREE.Color('#72645b');

		loader = new STLLoader();

		loadItems();

		scene.add(new THREE.HemisphereLight(0x443333, 0x111122));

		addShadowedLight(1, 1, 1, 0xffffff, 1.35);
		addShadowedLight(0.5, 1, -1, 0xffaa00, 1);

		renderer = new THREE.WebGLRenderer({antialias: true});
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.outputEncoding = THREE.sRGBEncoding;

		renderer.shadowMap.enabled = true;

		container.appendChild(renderer.domElement);

		initControls();

		stats = new Stats();
		container.appendChild(stats.dom);

		window.addEventListener('resize', onWindowResize, false);
		setEventListeners();

		initPostProcessing();


	}


	function addShadowedLight(x, y, z, color, intensity) {

		var directionalLight = new THREE.DirectionalLight(color, intensity);
		directionalLight.position.set(x, y, z);
		scene.add(directionalLight);

		directionalLight.castShadow = true;

		var d = 1;
		directionalLight.shadow.camera.left = -d;
		directionalLight.shadow.camera.right = d;
		directionalLight.shadow.camera.top = d;
		directionalLight.shadow.camera.bottom = -d;

		directionalLight.shadow.camera.near = 1;
		directionalLight.shadow.camera.far = 4;

		directionalLight.shadow.bias = -0.002;

	}

	function onWindowResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize(window.innerWidth, window.innerHeight);

	}

	function animate() {

		requestAnimationFrame(animate);
		controls.update();
		render();
		stats.update();
		composer.render();

	}

	function render() {

		renderer.render(scene, camera);

	}

</script>
</body>
</html>
