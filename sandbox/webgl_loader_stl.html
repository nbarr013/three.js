<!DOCTYPE html>
<html lang="en">
<head>
	<title>Allegion Products</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="../examples/main.css">
</head>
<body>
<div id="info">
	<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> -
</div>

<script type="module">

	import * as THREE from '../build/three.module.js';

	import Stats from '../examples/jsm/libs/stats.module.js';
	import {OrbitControls} from '../examples/jsm/controls/OrbitControls.js';
	import {STLLoader} from '../examples/jsm/loaders/STLLoader.js';
	import {DDSLoader} from '../examples/jsm/loaders/DDSLoader.js';
	import {MTLLoader} from '../examples/jsm/loaders/MTLLoader.js';
	import {OBJLoader} from '../examples/jsm/loaders/OBJLoader.js';
	import {FBXLoader} from '../examples/jsm/loaders/FBXLoader.js';
	import {TDSLoader} from '../examples/jsm/loaders/TDSLoader.js';
	import {TGALoader} from '../examples/jsm/loaders/TGALoader.js';

	import {EffectComposer} from '../examples/jsm/postprocessing/EffectComposer.js';
	import {RenderPass} from '../examples/jsm/postprocessing/RenderPass.js';
	import {ShaderPass} from '../examples/jsm/postprocessing/ShaderPass.js';
	import {OutlinePass} from '../examples/jsm/postprocessing/OutlinePass.js';
	import {FXAAShader} from '../examples/jsm/shaders/FXAAShader.js';


	var container, stats;

	var camera, controls, cameraTarget, scene, renderer, loader;
	let composer, effectFXAA, outlinePass;
	let raycaster = new THREE.Raycaster();
	let mouse = new THREE.Vector2();
	let intersection = null;

	let doorHandleMaterial, doorHandleMesh;
	let camLockMaterial, camLockMesh;

	let mixer;


	let allMeshsLoaded;
	let numberOfMeshsLoaded = 0;


	let onProgress = function (xhr) {
		if (xhr.lengthComputable) {
			let percentComplete = xhr.loaded / xhr.total * 100;
			console.log(Math.round(percentComplete, 2) + '% downloaded');
		}
	};

	let onError = function () {
	};

	init();
	animate();

	function initControls() {
		controls = new OrbitControls(camera, renderer.domElement);

		controls.enableDamping = true;
		controls.dampingFactor = 0.05;

		controls.screenSpacePanning = true;

		controls.minDistance = 0;
		controls.maxDistance = 500;

	}


	function meshLoaded(id) {
		let meshArr = [doorHandleMesh, camLockMesh, pushBtnMesh];
		for (let i = 0; i < meshArr.length; i++) {
			if (id === meshArr[i].uuid) {
				numberOfMeshsLoaded++;
			}
		}
		if (numberOfMeshsLoaded === meshArr.length) {
			allMeshsLoaded = true;
		}
	}

	var onLoad = function (texture) {

		console.log(texture);
		console.log("running")
		let meshArr = [doorHandleMesh, camLockMesh, pushBtnMesh, krytMesh, pushBarMesh];
		for (let i = 0; i < meshArr.length; i++) {
			if (texture.uuid === meshArr[i].uuid) {
				numberOfMeshsLoaded++;
			}
		}
		if (numberOfMeshsLoaded === meshArr.length) {
			allMeshsLoaded = true;
		}
	};


	function loadDoorHandle() {
		loader.load('../sandbox/models/door-handle/door-handle.stl', function (geometry) {

			doorHandleMaterial = new THREE.MeshPhongMaterial({color: "#989699", specular: 0x111111, shininess: 200});
			geometry.scale(.25, .25, .25);
			doorHandleMesh = new THREE.Mesh(geometry, doorHandleMaterial);

			doorHandleMesh.position.set(0, .01, 4);
			doorHandleMesh.rotation.set(0, -Math.PI / 2, 0);
			doorHandleMesh.scale.set(0.5, 0.5, 0.5);

			doorHandleMesh.castShadow = true;
			doorHandleMesh.receiveShadow = true;

			scene.add(doorHandleMesh);

		}/*, onLoad*/);

	}

	function loadCamLocks() {
		loader.load('../sandbox/models/sts-cam-locks/Bravica.stl', function (geometry) {

			camLockMaterial = new THREE.MeshPhongMaterial({color: '#84847a', specular: 0x111111, shininess: 200});
			if (geometry.hasColors) {
				camLockMaterial = new THREE.MeshPhongMaterial({
					opacity: geometry.alpha,
					vertexColors: THREE.VertexColors
				});
			}

			camLockMesh = new THREE.Mesh(geometry, camLockMaterial);

			camLockMesh.position.set(4, 0.2, -2);
			camLockMesh.rotation.set(-Math.PI / 2, Math.PI / 2, 0);
			camLockMesh.scale.set(0.3, 0.3, 0.3);

			camLockMesh.castShadow = true;
			camLockMesh.receiveShadow = true;

			scene.add(camLockMesh);

		}/*, onLoad*/);

	}

	function loadDoorThroughObjAndMTL() {

		let manager = new THREE.LoadingManager();
		manager.addHandler(/\.dds$/i, new DDSLoader());
		// comment in the following line and import TGALoader if your asset uses TGA textures
		manager.addHandler(/\.tga$/i, new TGALoader());

		new MTLLoader(manager)
				.setPath('../sandbox/models/Room-Door/')
				.load('Door_Component_BI3.mtl', function (materials) {

					materials.preload();

					new OBJLoader(manager)
							.setMaterials(materials)
							.setPath('../sandbox/models/Room-Door/')
							.load('Door_Component_BI3.obj', function (object) {

								object.position.y = -5;
								scene.add(object);

							}, onProgress, onError);

				});


	}


	function loadDoorThroughFBX() {
		var loader = new FBXLoader();
		loader.load('../sandbox/models/Room-Door/Door_Component_BI3.fbx', function (object) {
			/*mixer = new THREE.AnimationMixer(object);
			var action = mixer.clipAction(object.animations[0]);
			action.play();*/
			console.log(object);
			object.scale.set(0.1, 0.1, 0.1);
			object.position.set(-2, -5, -4);

			object.traverse(function (child) {
				if (child.isMesh) {
					child.castShadow = true;
					child.receiveShadow = true;
				}
			});
			scene.add(object);
		});
	}

	function loadDoorThrough3ds() {
		let textureloader = new THREE.TextureLoader();
		let normal = textureloader.load('../sandbox/models/Room-Door/textures/Door_C.jpg');

		let doorloader = new TDSLoader();
		doorloader.setResourcePath('../sandbox/models/Room-Door/');
		doorloader.load('../sandbox/models/Room-Door/Door_Component_BI3.3ds', function (object) {
			object.traverse(function (child) {
				if (child.isMesh) {
					child.material.normalMap = normal;
				}
			});

			scene.add(object);

		});

	}

	function loadItems() {
		loadDoorHandle();
		loadCamLocks();
		//loadDoorThroughObjAndMTL();
		loadDoorThroughFBX();
		//loadDoorThrough3ds();
	}

	function doesIntersect(meshToTest) {
		let intersects = raycaster.intersectObject(meshToTest);
		if (intersects.length > 0) {
			return meshToTest.uuid === intersects[0].object.uuid;
		} else {
			return false;
		}
	}

	function checkForHoverOnItems() {
		let objsToCheck = [doorHandleMesh, camLockMesh];

		/* TODO add check for hover
				if (allMeshsLoaded){
					objsToCheck = [doorHandleMesh, camLockMesh];
				}
		*/

		let noIntersection = true;
		for (let i = 0; i < objsToCheck.length; i++) {
			if (doesIntersect(objsToCheck[i])) {
				outlinePass.selectedObjects = [objsToCheck[i]];
				noIntersection = false;
			}
		}
		if (noIntersection) {
			outlinePass.selectedObjects = [];
		}
	}

	function onMouseMove(event) {
		mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
		mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
		raycaster.setFromCamera(mouse, camera);
		checkForHoverOnItems();
	}

	function setEventListeners() {
		container.addEventListener('mousemove', onMouseMove, false);
	}

	function initPostProcessing() {

		composer = new EffectComposer(renderer);
		let renderPass = new RenderPass(scene, camera);
		composer.addPass(renderPass);

		outlinePass = new OutlinePass(new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera);
		composer.addPass(outlinePass);
		effectFXAA = new ShaderPass(FXAAShader);
		effectFXAA.uniforms['resolution'].value.set(1 / window.innerWidth, 1 / window.innerHeight);
		composer.addPass(effectFXAA);


	}

	function init() {

		container = document.createElement('div');
		document.body.appendChild(container);

		camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, .1, 1000);
		camera.position.set(3, 0.15, 3);

		cameraTarget = new THREE.Vector3(0, -0.25, 0);

		scene = new THREE.Scene();
		scene.background = new THREE.Color('#72645b');

		loader = new STLLoader();

		loadItems();

		scene.add(new THREE.HemisphereLight(0x443333, 0x111122));

		addShadowedLight(1, 1, 1, 0xffffff, 1.35);
		addShadowedLight(0.5, 1, -1, 0xffaa00, 1);

		renderer = new THREE.WebGLRenderer({antialias: true});
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.outputEncoding = THREE.sRGBEncoding;

		renderer.shadowMap.enabled = true;

		container.appendChild(renderer.domElement);

		initControls();

		stats = new Stats();
		container.appendChild(stats.dom);

		window.addEventListener('resize', onWindowResize, false);
		setEventListeners();

		initPostProcessing();


	}


	function addShadowedLight(x, y, z, color, intensity) {

		var directionalLight = new THREE.DirectionalLight(color, intensity);
		directionalLight.position.set(x, y, z);
		scene.add(directionalLight);

		directionalLight.castShadow = true;

		var d = 1;
		directionalLight.shadow.camera.left = -d;
		directionalLight.shadow.camera.right = d;
		directionalLight.shadow.camera.top = d;
		directionalLight.shadow.camera.bottom = -d;

		directionalLight.shadow.camera.near = 1;
		directionalLight.shadow.camera.far = 4;

		directionalLight.shadow.bias = -0.002;

	}

	function onWindowResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize(window.innerWidth, window.innerHeight);

	}

	function animate() {

		requestAnimationFrame(animate);
		controls.update();
		render();
		stats.update();
		composer.render();
		//if (mixer) mixer.update(delta);


	}

	function render() {

		renderer.render(scene, camera);

	}

</script>
</body>
</html>
